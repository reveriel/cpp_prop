# C++ 命题逻辑证明器

本项目通过 C++ 的类型系统和函数式编程思想，实现了一个命题逻辑的定理证明器。它旨在探索和展示深刻的 **Curry-Howard 同构** 思想，即 **“命题即类型，证明即程序”**。

在这个框架下：
- **逻辑命题** 被编码为 C++ 的 **类型** (例如 `Implies<A, B>`)。
- **逻辑证明** 是相应类型的 **实例** (即一个函数或一个值)。
- **C++ 编译器** 扮演了 **证明检查器** 的角色。如果代码能够成功编译，就意味着其所代表的逻辑证明在类型上是有效的。

---

## 项目结构

项目被清晰地划分为四个核心部分，展示了两种不同的命题逻辑实现方法：

1.  `template.h`
    - **方法:** 采用 **模板元编程** 实现命题逻辑演算。
    - **原理:** 将命题的真值（`TrueType` 和 `FalseType`）编码为 C++ 类型，并通过模板特化和 `static_assert` 在 **编译期** 对逻辑表达式进行求值。这本质上模拟了 **真值表** 的计算。
    - **特点:** 这种方法属于 **经典逻辑** 的范畴，因为它通过枚举所有命题的真值组合来验证定理（重言式）。例如，`Syllogism` 的证明通过检查所有 2^3 = 8 种真值组合来确保其恒为真。

2.  `constructive_logic.h`
    - 这是一个头文件库，提供了所有 **构造性逻辑 (Constructive Logic)** 的核心工具。
    - 它定义了基础逻辑类型 (`True`, `False`, `And`, `Or`, `Not`, `Implies`) 和一系列基础的、可在构造性框架下被证明的定理，如 `modus_ponens`, `and_intro`, `or_elim`, 以及至关重要的 `principle_of_explosion`。
    - 这个库是本项目所有证明工作的基础。

3.  `prover.cpp`
    - 一个简单的可执行文件，它 `#include "constructive_logic.h"`。
    - 其 `main` 函数通过一系列 `static_assert` 展示了如何使用库中的工具来构建和验证基础的 **构造性** 定理。
    - 它是理解本项目核心思想的绝佳起点。

4.  `enhanced_prover.cpp`
    - 一个更高级的可执行文件，它同样基于 `constructive_logic.h`。
    - 这个文件的核心是展示 **经典逻辑 (Classical Logic)** 中三个著名公理之间的 **等价性**：
        - **排中律 (Law of Excluded Middle):** `A ∨ ¬A`
        - **双重否定除去 (Double Negation Elimination):** `¬¬A → A`
        - **皮尔士定律 (Peirce's Law):** `((A → B) → A) → A`
    - 它通过实现一系列“证明转换”函数来做到这一点。这些函数接受其中一个公理的证明作为 **函数参数**，然后返回另一个公理的证明。如果这个文件能够编译，就从类型层面证明了它们的逻辑等价关系。

---

## 核心概念：构造性逻辑 vs. 经典逻辑

本项目的一个关键亮点是揭示了构造性逻辑和经典逻辑的根本区别，并通过两种不同的 C++ 实现方法进行了对比：

- **经典逻辑 (由 `template.h` 代表):** 关注命题的真值。一个命题是真理，当且仅当它在所有可能的真值赋值下都为真（即它是重言式）。`template.h` 通过编译期枚举所有真值组合来验证这一点。

- **构造性逻辑 (由 `constructive_logic.h`, `prover.cpp`, `enhanced_prover.cpp` 代表):** 关注命题的 **可构造性** 或 **可证明性**。一个命题是真理，当且仅当存在一个程序（证明）能够构造出它的实例。例如，要证明 `A ∨ B`，你必须明确地构造出 `A` 的实例或 `B` 的实例。因此，像排中律 (`A ∨ ¬A`) 这样的定理在纯构造性逻辑中是 **无法被普遍证明的**，因为你无法总是构造出 `A` 或 `¬A` 的实例。

- **桥梁:** 经典逻辑允许非构造性的推理，例如反证法。三大公理（排中律、双重否定除去、皮尔士定律）是其基石。`enhanced_prover.cpp` 演示了，如果你将其中任意一个作为公理添加到构造性系统中，整个系统就会“升级”为经典逻辑，另外两个定理也就立刻变得可以证明了。这完美地展示了这些公理在逻辑体系中的强大作用。

---

## 证明器的局限性

当前项目主要聚焦于**命题逻辑**的证明。虽然 C++ 的类型系统在编译时充当证明检查器非常强大和优雅，但它在处理更复杂的数学领域时存在固有的局限性：

-   **谓词逻辑与量词：** 本证明器无法直接处理像“所有整数 `x`” (`∀x`) 或“存在一个 `x`” (`∃x`) 这样的量词。命题逻辑不关心命题的内部结构，也无法表达关于变量的属性或关系。
-   **无限域的证明：** 对于像自然数这样无限的集合，要证明“对于所有自然数 `n`，某个性质 `P(n)` 成立”，通常需要**数学归纳法**。C++ 的类型系统难以通用地表达和执行数学归纳法，因为这需要处理无限多的类型实例。
-   **通用性与可扩展性：** 尝试在 C++ 类型系统中模拟复杂的数学概念和证明规则（如通用归纳法），往往会导致代码变得极其复杂、晦涩，且难以扩展到新的数学领域。

对于需要处理谓词逻辑、量词和归纳证明的复杂数学定理，专业的**证明助手 (Proof Assistants)** 或**依赖类型编程语言**（如 Coq, Agda, Idris）是更合适的工具，它们提供了专门为形式化数学证明设计的语言特性和推理引擎。

---

## 如何构建

本项目使用 CMake 进行构建。请确保你已经安装了 CMake 和一个现代的 C++ 编译器 (支持 C++17)。

```bash
# 1. 克隆仓库
# git clone ...

# 2. 创建并进入 build 目录
mkdir build
cd build

# 3. 运行 CMake 来配置项目
cmake ..

# 4. 编译所有目标 (包括 prover, enhanced_prover, 和 tests)
make
```

编译成功后，你可以在 `build` 目录下找到 `prover` 和 `enhanced_prover` 这两个可执行文件。运行它们会输出编译成功的确认信息。

```bash
./prover
./enhanced_prover
```